---
title: 'Go API'
---

## Overview

The Parallax client reusable Go libraries focus on three main usage areas:

* Simplified client side account management
* Remote node interfacing via different transports
* Contract interactions through auto-generated bindings

The libraries are updated synchronously with the Parallax client GitHub repository. The Go libraries can be viewed in full at [Go Packages](https://pkg.go.dev/github.com/microstack-tech/parallax#section-directories).

## Go packages

The `parallax` library is distributed as a collection of standard Go packages straight from Parallax's GitHub repository. The packages can be used directly via the official Go toolkit, without needing any third party tools.

The canonical import path for the Parallax client is `github.com/microstack-tech/parallax`, with all packages residing underneath. Although there are [lots of them](https://pkg.go.dev/github.com/microstack-tech/parallax/#section-directories) most developers will only care about a limited subset.

All the Parallax client packages can be downloaded using:

```sh
go get -d github.com/microstack-tech/parallax/...
```

More Go API support for dapp developers can be found on the [Go Contract Bindings](./go-contract-bindings) and [Go Account Management](./go-account-management) pages.

## Tutorial

This section includes some basic usage examples for the `prlclient` and `prlxclient` packages available as part of the Go API. The `prlclient` package provides a client that implements the full Parallax JSON-RPC API, whereas `prlxclient` offers the Parallax client specific API.

### Instantiating a client

The client is an instance of the Client struct which has associated functions that wrap requests to the Parallax client RPC API endpoints.

A client is instantiated by passing a raw url or path to an ipc file to the client's Dial function. In the following code snippet the path to the ipc file for a local Parallax client is provided to prlclient.Dial().

```go
// create instance of prlclient and assign to cl
cl, err := prlclient.Dial("/tmp/prlx.ipc")
if err != nil {
 panic(err)
}
_ = cl
```

### Interacting with the client

The client can now be used to handle requests to the Parallax client using the full JSON-RPC API. For example, the function `BlockNumber()` wraps a call to the `eth_blockNumber` endpoint. The function `SendTransaction` wraps a call to `eth_sendTransaction`. The full list of client methods can be found [here](https://pkg.go.dev/github.com/microstack-tech/parallax/prlclient#Client).

Frequently, the functions take an instance of the Context type as their leading argument. This defines context about requests sent from the application such as deadlines, cancellation signals etc. More information on this can be found in the [Go documentation](https://pkg.go.dev/golang.org/x/net/context). An empty context instance can be created using `Context.Background()`.

### Querying client for data

A simple starting point is to fetch the chain ID from the client. This e.g. is needed when signing a transaction as is to be seen in the next section.

```go
chainid, err := cl.ChainID(context.Background())
if err != nil {
    return err
}
```

Unlike `ChainID`, many functions require arguments other than context. The Go API takes in and returns high-level types which are used in the Parallax client internals as well to simplify programming and remove the need for knowing how data needs to be formatted exactly as per the JSON-RPC API spec. For example to find out the nonce for an account at a given block the address needs to be provided as a `common.Address` type and the block number as a `*big.Int`:

```go
addr := common.HexToAddress("0xb02A2EdA1b317FBd16760128836B0Ac59B560e9D")
nonce, err := cl.NonceAt(context.Background(), addr, big.NewInt(14000000))
```

### Querying past events

Contracts emit events during execution which can be queried from the client. The parameters for the event one is interested in have to be filled out in the `parallax.FilterQuery` object. This includes which event topics are of interest, from which contracts and during which range of blocks. The example below queries Transfer events of all ERC-20 tokens for the last 10 blocks:

```go
blockNumber, err := cl.BlockNumber(context.Background())
if err != nil {
 fmt.Println("Failed to retrieve block number:", err)
 return
}
blockNumberBig := big.NewInt(int64(blockNumber))

eventSignatureBytes := []byte("Transfer(address,address,uint256)")
eventSignaturehash := crypto.Keccak256Hash(eventSignatureBytes)

q := parallax.FilterQuery{
 FromBlock: new(big.Int).Sub(blockNumberBig, big.NewInt(10)),
 ToBlock:   blockNumberBig,
 Topics: [][]common.Hash{
  {eventSignaturehash},
 },
}

logs, err := cl.FilterLogs(context.Background(), q)
if err != nil {
    return err
}
```

### Sending a transaction

Sending a transaction is achieved using the `SendTransaction()` function. `SendTransaction` takes an instance of `context.Context` as its leading argument and a signed transaction as its second argument. The signed transaction must be generated in advance. Building the signed transaction is a multi-stage process that requires first generating a key pair if none exists already, retrieving some chain data and defining sender and recipient addresses. Then these data can be collected into a transaction object and signed. The resulting signed transaction can then be passed to `SendTransaction`.

The example below assumes the following key pair has already been generated:

```go
// SK and ADDR are the secret key and sender address
SK   = "0xaf5ead4413ff4b78bc94191a2926ae9ccbec86ce099d65aaf469e9eb1a0fa87f"
ADDR = "0x6177843db3138ae69679A54b95cf345ED759450d"
```

The secret key and address can be used to send a transaction. In the example below `1 Lax` is sent from the address `ADDR` to an arbitrary recipient.

```go
import (
 "context"
 "math/big"

 "github.com/microstack-tech/parallax/common"
 "github.com/microstack-tech/parallax/core/types"
 "github.com/microstack-tech/parallax/crypto"
 "github.com/microstack-tech/parallax/prlclient"
 "github.com/microstack-tech/parallax/params"
)

// sendTransaction sends a transaction with 1 Lax to a specified address.
func sendTransaction(cl *prlclient.Client) error {
 var (
  sk       = crypto.ToECDSAUnsafe(common.FromHex(SK))
  to       = common.HexToAddress("0xb02A2EdA1b317FBd16760128836B0Ac59B560e9D")
  value    = new(big.Int).Mul(big.NewInt(1), big.NewInt(params.Ether))
  sender   = common.HexToAddress(ADDR)
  gasLimit = uint64(21000)
 )
 // Retrieve the chainid (needed for signer)
 chainid, err := cl.ChainID(context.Background())
 if err != nil {
  return err
 }
 // Retrieve the pending nonce
 nonce, err := cl.PendingNonceAt(context.Background(), sender)
 if err != nil {
  return err
 }
 // Get suggested gas price
 tipCap, _ := cl.SuggestGasTipCap(context.Background())
 feeCap, _ := cl.SuggestGasPrice(context.Background())
 // Create a new transaction
 tx := types.NewTx(
  &types.DynamicFeeTx{
   ChainID:   chainid,
   Nonce:     nonce,
   GasTipCap: tipCap,
   GasFeeCap: feeCap,
   Gas:       gasLimit,
   To:        &to,
   Value:     value,
   Data:      nil,
  })
 // Sign the transaction using our keys
 signedTx, _ := types.SignTx(tx, types.NewLondonSigner(chainid), sk)
 // Send the transaction to our node
 return cl.SendTransaction(context.Background(), signedTx)
}
```

### prlxclient

An instance of `prlxclient` can be used in exactly the same way as `prlclient`. However, `prlxclient` includes the Parallax client specific API methods. These additional methods are:

```sh
CallContract()
CreateAccessList()
GCStats()
GetNodeInfo()
GetProof()
MemStats()
SetHead()
SubscribePendingTransactions()
```

*Note that both `prlclient` and `prlxclient` have a `CallContract()` function - the difference is that the `prlxclient` version includes an overrides argument.*

Details relating to these endpoints can be found at [pkg.go.dev](https://pkg.go.dev/github.com/microstack-tech/parallax/prlclient/prlxclient) or the Parallax client [GitHub](https://github.com/microstack-tech/parallax/tree/main/prlclient).

## Summary

There are a wide variety of Go APIs available for dapp developers that abstract away the complexity of interacting with Parallax using a set of composable, reusable functions provided by the Parallax client.
